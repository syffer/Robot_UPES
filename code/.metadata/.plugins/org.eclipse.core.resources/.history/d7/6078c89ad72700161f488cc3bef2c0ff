package transform;

public class Complex {
	
	public static final Complex zero = new Complex(0, 0);
	public static final Complex one = new Complex(1, 0);
	
	public double reel;
	public double image;

	public Complex() {
		this(0, 0);
	}
	
	public Complex(double number) {
		this(number, 0);
	}
	
	public Complex(double reel, double image) {
		this.reel = reel; 
		this.image = image;
	}
	
	
	@Override
	public String toString() {
		return "Complexe [reel=" + reel + ", image=" + image + "]";
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		long temp;
		temp = Double.doubleToLongBits(image);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(reel);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}




	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Complex other = (Complex) obj;
		if (Double.doubleToLongBits(image) != Double
				.doubleToLongBits(other.image))
			return false;
		if (Double.doubleToLongBits(reel) != Double
				.doubleToLongBits(other.reel))
			return false;
		return true;
	}


	public static Complex inv(Complex c) throws ComplexeException {
		if(c.equals(Complex.zero)) throw new ComplexeException("[0,0] has no inverse");
		double denominator = c.reel * c.reel + c.image * c.image;
		return new Complex(c.reel / denominator, -c.image / denominator);
	}

	public static Complex neg(Complex complexe) {
		return new Complex(-complexe.reel, -complexe.image);
	}
	
	public static Complex add(Complex a, Complex b) {
		return new Complex(a.reel + b.reel, a.image + b.image);
	}
	
	public static Complex sub(Complex a, Complex b) {
		return new Complex(a.reel - b.reel, a.image - b.image);
	}
	
	public static Complex mul(Complex a, Complex b) {
		return new Complex(a.reel * b.reel - a.image * b.image, a.reel * b.image - a.image * b.reel);
	}
	
	public static Complex div(Complex a, Complex b) throws ComplexeException {
		if(b.equals(Complex.zero)) throw new ComplexeException("divide by [0,0] is impossible");
		double deno = b.reel * b.reel + b.image * b.image;
		return new Complex((a.reel * b.reel + a.image * b.image) / deno, (a.image * b.reel - a.reel * b.image) / deno);
	}
	
}
